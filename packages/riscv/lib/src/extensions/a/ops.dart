import '../../ops.dart';
import '../../riscv_isa_base.dart';
import '../../riscv_isa_decode.dart';

/// RV32A extension
///
/// {@category extensions}
const rv32Atomics = RiscVExtension(
  [
    Operation<RType>(
      mnemonic: 'lr.w',
      opcode: 0x2F,
      funct3: 0x2,
      funct7: 0x8,
      struct: RType.STRUCT,
      constructor: RType.map,
      microcode: [
        ReadRegisterMicroOp(MicroOpField.rs1),
        LoadReservedMicroOp(
          MicroOpField.rs1,
          MicroOpField.rd,
          MicroOpMemSize.word,
        ),
        UpdatePCMicroOp(MicroOpField.pc, offset: 4),
      ],
    ),
    Operation<RType>(
      mnemonic: 'sc.w',
      opcode: 0x2F,
      funct3: 0x2,
      funct7: 0xC,
      struct: RType.STRUCT,
      constructor: RType.map,
      microcode: [
        ReadRegisterMicroOp(MicroOpField.rs1),
        ReadRegisterMicroOp(MicroOpField.rs2),
        StoreConditionalMicroOp(
          base: MicroOpField.rs1,
          src: MicroOpField.rs2,
          dest: MicroOpField.rd,
          size: MicroOpMemSize.word,
        ),
        UpdatePCMicroOp(MicroOpField.pc, offset: 4),
      ],
    ),
    Operation<RType>(
      mnemonic: 'amoadd.w',
      opcode: 0x2F,
      funct3: 0x2,
      funct7: 0x0,
      struct: RType.STRUCT,
      constructor: RType.map,
      microcode: [
        ReadRegisterMicroOp(MicroOpField.rs1),
        ReadRegisterMicroOp(MicroOpField.rs2),
        AtomicMemoryMicroOp(
          funct: MicroOpAtomicFunct.add,
          base: MicroOpField.rs1,
          src: MicroOpField.rs2,
          dest: MicroOpField.rd,
          size: MicroOpMemSize.word,
        ),
        UpdatePCMicroOp(MicroOpField.pc, offset: 4),
      ],
    ),
    Operation<RType>(
      mnemonic: 'amoswap.w',
      opcode: 0x2F,
      funct3: 0x2,
      funct7: 0x4,
      struct: RType.STRUCT,
      constructor: RType.map,
      microcode: [
        ReadRegisterMicroOp(MicroOpField.rs1),
        ReadRegisterMicroOp(MicroOpField.rs2),
        AtomicMemoryMicroOp(
          funct: MicroOpAtomicFunct.swap,
          base: MicroOpField.rs1,
          src: MicroOpField.rs2,
          dest: MicroOpField.rd,
          size: MicroOpMemSize.word,
        ),
        UpdatePCMicroOp(MicroOpField.pc, offset: 4),
      ],
    ),
    Operation<RType>(
      mnemonic: 'amoxor.w',
      opcode: 0x2F,
      funct3: 0x2,
      funct7: 0x10,
      struct: RType.STRUCT,
      constructor: RType.map,
      microcode: [
        ReadRegisterMicroOp(MicroOpField.rs1),
        ReadRegisterMicroOp(MicroOpField.rs2),
        AtomicMemoryMicroOp(
          funct: MicroOpAtomicFunct.xor,
          base: MicroOpField.rs1,
          src: MicroOpField.rs2,
          dest: MicroOpField.rd,
          size: MicroOpMemSize.word,
        ),
        UpdatePCMicroOp(MicroOpField.pc, offset: 4),
      ],
    ),
    Operation<RType>(
      mnemonic: 'amoand.w',
      opcode: 0x2F,
      funct3: 0x2,
      funct7: 0x20,
      struct: RType.STRUCT,
      constructor: RType.map,
      microcode: [
        ReadRegisterMicroOp(MicroOpField.rs1),
        ReadRegisterMicroOp(MicroOpField.rs2),
        AtomicMemoryMicroOp(
          funct: MicroOpAtomicFunct.and,
          base: MicroOpField.rs1,
          src: MicroOpField.rs2,
          dest: MicroOpField.rd,
          size: MicroOpMemSize.word,
        ),
        UpdatePCMicroOp(MicroOpField.pc, offset: 4),
      ],
    ),
    Operation<RType>(
      mnemonic: 'amoor.w',
      opcode: 0x2F,
      funct3: 0x2,
      funct7: 0x30,
      struct: RType.STRUCT,
      constructor: RType.map,
      microcode: [
        ReadRegisterMicroOp(MicroOpField.rs1),
        ReadRegisterMicroOp(MicroOpField.rs2),
        AtomicMemoryMicroOp(
          funct: MicroOpAtomicFunct.or,
          base: MicroOpField.rs1,
          src: MicroOpField.rs2,
          dest: MicroOpField.rd,
          size: MicroOpMemSize.word,
        ),
        UpdatePCMicroOp(MicroOpField.pc, offset: 4),
      ],
    ),
    Operation<RType>(
      mnemonic: 'amomin.w',
      opcode: 0x2F,
      funct3: 0x2,
      funct7: 0x40,
      struct: RType.STRUCT,
      constructor: RType.map,
      microcode: [
        ReadRegisterMicroOp(MicroOpField.rs1),
        ReadRegisterMicroOp(MicroOpField.rs2),
        AtomicMemoryMicroOp(
          funct: MicroOpAtomicFunct.min,
          base: MicroOpField.rs1,
          src: MicroOpField.rs2,
          dest: MicroOpField.rd,
          size: MicroOpMemSize.word,
        ),
        UpdatePCMicroOp(MicroOpField.pc, offset: 4),
      ],
    ),
    Operation<RType>(
      mnemonic: 'amomax.w',
      opcode: 0x2F,
      funct3: 0x2,
      funct7: 0x50,
      struct: RType.STRUCT,
      constructor: RType.map,
      microcode: [
        ReadRegisterMicroOp(MicroOpField.rs1),
        ReadRegisterMicroOp(MicroOpField.rs2),
        AtomicMemoryMicroOp(
          funct: MicroOpAtomicFunct.max,
          base: MicroOpField.rs1,
          src: MicroOpField.rs2,
          dest: MicroOpField.rd,
          size: MicroOpMemSize.word,
        ),
        UpdatePCMicroOp(MicroOpField.pc, offset: 4),
      ],
    ),
    Operation<RType>(
      mnemonic: 'amominu.w',
      opcode: 0x2F,
      funct3: 0x2,
      funct7: 0x60,
      struct: RType.STRUCT,
      constructor: RType.map,
      microcode: [
        ReadRegisterMicroOp(MicroOpField.rs1),
        ReadRegisterMicroOp(MicroOpField.rs2),
        AtomicMemoryMicroOp(
          funct: MicroOpAtomicFunct.minu,
          base: MicroOpField.rs1,
          src: MicroOpField.rs2,
          dest: MicroOpField.rd,
          size: MicroOpMemSize.word,
        ),
        UpdatePCMicroOp(MicroOpField.pc, offset: 4),
      ],
    ),
    Operation<RType>(
      mnemonic: 'amomaxu.w',
      opcode: 0x2F,
      funct3: 0x2,
      funct7: 0x70,
      struct: RType.STRUCT,
      constructor: RType.map,
      microcode: [
        ReadRegisterMicroOp(MicroOpField.rs1),
        ReadRegisterMicroOp(MicroOpField.rs2),
        AtomicMemoryMicroOp(
          funct: MicroOpAtomicFunct.maxu,
          base: MicroOpField.rs1,
          src: MicroOpField.rs2,
          dest: MicroOpField.rd,
          size: MicroOpMemSize.word,
        ),
        UpdatePCMicroOp(MicroOpField.pc, offset: 4),
      ],
    ),
  ],
  name: 'A',
  key: 'A',
  mask: 1 << 0,
);

/// RV64A extension
///
/// {@category extensions}
const rv64Atomics = RiscVExtension(
  [
    Operation<RType>(
      mnemonic: 'lr.d',
      opcode: 0x2F,
      funct3: 0x3,
      funct7: 0x8,
      struct: RType.STRUCT,
      constructor: RType.map,
      microcode: [
        ReadRegisterMicroOp(MicroOpField.rs1),
        LoadReservedMicroOp(
          MicroOpField.rs1,
          MicroOpField.rd,
          MicroOpMemSize.dword,
        ),
        UpdatePCMicroOp(MicroOpField.pc, offset: 4),
      ],
    ),
    Operation<RType>(
      mnemonic: 'sc.d',
      opcode: 0x2F,
      funct3: 0x3,
      funct7: 0xC,
      struct: RType.STRUCT,
      constructor: RType.map,
      microcode: [
        ReadRegisterMicroOp(MicroOpField.rs1),
        ReadRegisterMicroOp(MicroOpField.rs2),
        StoreConditionalMicroOp(
          base: MicroOpField.rs1,
          src: MicroOpField.rs2,
          dest: MicroOpField.rd,
          size: MicroOpMemSize.dword,
        ),
        UpdatePCMicroOp(MicroOpField.pc, offset: 4),
      ],
    ),
    Operation<RType>(
      mnemonic: 'amoadd.d',
      opcode: 0x2F,
      funct3: 0x3,
      funct7: 0x0,
      struct: RType.STRUCT,
      constructor: RType.map,
      microcode: [
        ReadRegisterMicroOp(MicroOpField.rs1),
        ReadRegisterMicroOp(MicroOpField.rs2),
        AtomicMemoryMicroOp(
          funct: MicroOpAtomicFunct.add,
          base: MicroOpField.rs1,
          src: MicroOpField.rs2,
          dest: MicroOpField.rd,
          size: MicroOpMemSize.dword,
        ),
        UpdatePCMicroOp(MicroOpField.pc, offset: 4),
      ],
    ),
    Operation<RType>(
      mnemonic: 'amoswap.d',
      opcode: 0x2F,
      funct3: 0x3,
      funct7: 0x4,
      struct: RType.STRUCT,
      constructor: RType.map,
      microcode: [
        ReadRegisterMicroOp(MicroOpField.rs1),
        ReadRegisterMicroOp(MicroOpField.rs2),
        AtomicMemoryMicroOp(
          funct: MicroOpAtomicFunct.swap,
          base: MicroOpField.rs1,
          src: MicroOpField.rs2,
          dest: MicroOpField.rd,
          size: MicroOpMemSize.dword,
        ),
        UpdatePCMicroOp(MicroOpField.pc, offset: 4),
      ],
    ),
    Operation<RType>(
      mnemonic: 'amoxor.d',
      opcode: 0x2F,
      funct3: 0x3,
      funct7: 0x10,
      struct: RType.STRUCT,
      constructor: RType.map,
      microcode: [
        ReadRegisterMicroOp(MicroOpField.rs1),
        ReadRegisterMicroOp(MicroOpField.rs2),
        AtomicMemoryMicroOp(
          funct: MicroOpAtomicFunct.xor,
          base: MicroOpField.rs1,
          src: MicroOpField.rs2,
          dest: MicroOpField.rd,
          size: MicroOpMemSize.dword,
        ),
        UpdatePCMicroOp(MicroOpField.pc, offset: 4),
      ],
    ),
    Operation<RType>(
      mnemonic: 'amoand.d',
      opcode: 0x2F,
      funct3: 0x3,
      funct7: 0x30,
      struct: RType.STRUCT,
      constructor: RType.map,
      microcode: [
        ReadRegisterMicroOp(MicroOpField.rs1),
        ReadRegisterMicroOp(MicroOpField.rs2),
        AtomicMemoryMicroOp(
          funct: MicroOpAtomicFunct.and,
          base: MicroOpField.rs1,
          src: MicroOpField.rs2,
          dest: MicroOpField.rd,
          size: MicroOpMemSize.dword,
        ),
        UpdatePCMicroOp(MicroOpField.pc, offset: 4),
      ],
    ),
    Operation<RType>(
      mnemonic: 'amoor.d',
      opcode: 0x2F,
      funct3: 0x3,
      funct7: 0x20,
      struct: RType.STRUCT,
      constructor: RType.map,
      microcode: [
        ReadRegisterMicroOp(MicroOpField.rs1),
        ReadRegisterMicroOp(MicroOpField.rs2),
        AtomicMemoryMicroOp(
          funct: MicroOpAtomicFunct.or,
          base: MicroOpField.rs1,
          src: MicroOpField.rs2,
          dest: MicroOpField.rd,
          size: MicroOpMemSize.dword,
        ),
        UpdatePCMicroOp(MicroOpField.pc, offset: 4),
      ],
    ),
    Operation<RType>(
      mnemonic: 'amomin.d',
      opcode: 0x2F,
      funct3: 0x3,
      funct7: 0x40,
      struct: RType.STRUCT,
      constructor: RType.map,
      microcode: [
        ReadRegisterMicroOp(MicroOpField.rs1),
        ReadRegisterMicroOp(MicroOpField.rs2),
        AtomicMemoryMicroOp(
          funct: MicroOpAtomicFunct.min,
          base: MicroOpField.rs1,
          src: MicroOpField.rs2,
          dest: MicroOpField.rd,
          size: MicroOpMemSize.dword,
        ),
        UpdatePCMicroOp(MicroOpField.pc, offset: 4),
      ],
    ),
    Operation<RType>(
      mnemonic: 'amomax.d',
      opcode: 0x2F,
      funct3: 0x3,
      funct7: 0x50,
      struct: RType.STRUCT,
      constructor: RType.map,
      microcode: [
        ReadRegisterMicroOp(MicroOpField.rs1),
        ReadRegisterMicroOp(MicroOpField.rs2),
        AtomicMemoryMicroOp(
          funct: MicroOpAtomicFunct.max,
          base: MicroOpField.rs1,
          src: MicroOpField.rs2,
          dest: MicroOpField.rd,
          size: MicroOpMemSize.dword,
        ),
        UpdatePCMicroOp(MicroOpField.pc, offset: 4),
      ],
    ),
    Operation<RType>(
      mnemonic: 'amominu.d',
      opcode: 0x2F,
      funct3: 0x3,
      funct7: 0x60,
      struct: RType.STRUCT,
      constructor: RType.map,
      microcode: [
        ReadRegisterMicroOp(MicroOpField.rs1),
        ReadRegisterMicroOp(MicroOpField.rs2),
        AtomicMemoryMicroOp(
          funct: MicroOpAtomicFunct.minu,
          base: MicroOpField.rs1,
          src: MicroOpField.rs2,
          dest: MicroOpField.rd,
          size: MicroOpMemSize.dword,
        ),
        UpdatePCMicroOp(MicroOpField.pc, offset: 4),
      ],
    ),
    Operation<RType>(
      mnemonic: 'amomaxu.d',
      opcode: 0x2F,
      funct3: 0x3,
      funct7: 0x70,
      struct: RType.STRUCT,
      constructor: RType.map,
      microcode: [
        ReadRegisterMicroOp(MicroOpField.rs1),
        ReadRegisterMicroOp(MicroOpField.rs2),
        AtomicMemoryMicroOp(
          funct: MicroOpAtomicFunct.maxu,
          base: MicroOpField.rs1,
          src: MicroOpField.rs2,
          dest: MicroOpField.rd,
          size: MicroOpMemSize.dword,
        ),
        UpdatePCMicroOp(MicroOpField.pc, offset: 4),
      ],
    ),
  ],
  name: 'A',
  key: 'A',
  mask: 1 << 0,
);
